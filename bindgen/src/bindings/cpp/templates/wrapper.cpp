/* This file was generated by uniffi-bindgen-cpp. */
{%- let namespace = ci.namespace() %}
{%- import "macros.cpp" as macros %}
#include <string>

#include "{{ ci.namespace() }}.hpp"

namespace {{ namespace }} {
namespace uniffi {
template <class> inline constexpr bool always_false_v = false;

namespace {
void ensure_initialized() {
    auto bindings_contract_version = {{ ci.uniffi_contract_version() }};
    auto scaffolding_contract_version = {{ ci.ffi_uniffi_contract_version().name() }}();

    if (bindings_contract_version != scaffolding_contract_version) {
        throw std::runtime_error("UniFFI contract version mismatch: try cleaning and rebuilding your project");
    }

    {%- for (name, expected_checksum) in ci.iter_checksums() %}
    if ({{ name }}() != {{ expected_checksum }}) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    {%- endfor %}

    {% for fn in self.initialization_fns() -%}
    {{ fn }}();
    {% endfor -%}
}

// Note: we need this indirection here and can't inline this code in the rust_call function
// as it's a templated function
void initialize() {
    static std::once_flag init_flag;
    std::call_once(init_flag, ensure_initialized);
}
}

template <typename F>
void check_rust_call(const RustCallStatus &status, F error_cb) {
    switch (status.code) {
    case 0:
        return;

    case 1:
        if constexpr (!std::is_null_pointer_v<F>) {
            error_cb(status.error_buf)->_uniffi_internal_throw_underlying();
        }
        break;

    case 2:
        if (status.error_buf.len > 0) {
            throw std::runtime_error({{ Type::String.borrow()|lift_fn }}(status.error_buf));
        }

        throw std::runtime_error("A Rust panic has occurred");
    }

    throw std::runtime_error("Unexpected Rust call status");
}

template <typename F, typename EF, typename... Args, typename R = std::invoke_result_t<F, Args..., RustCallStatus *>>
R rust_call(F f, EF error_cb, Args... args) {
    initialize();

    RustCallStatus status = { 0 };

    if constexpr (std::is_void_v<R>) {
        f(args..., &status);
        check_rust_call(status, error_cb);
    } else {
        auto ret = f(args..., &status);
        check_rust_call(status, error_cb);

        return ret;
    }
}

template <typename F, typename W>
void rust_call_trait_interface(RustCallStatus* status, F make_call, W write_value) {
    initialize();

    constexpr bool has_return_type = std::negation<std::is_same<void, std::invoke_result_t<F>>>::value;

    try {
        if constexpr(has_return_type) {
            write_value(make_call());
        } else {
            make_call();
        }
    } catch (std::exception &e) {
        status->code = 2;
        status->error_buf = {{ Type::String.borrow()|lower_fn }}(e.what());
    }
}

template <typename E, typename W, typename F, typename EF>
void rust_call_trait_interface_with_error(RustCallStatus* status, F make_call, W write_value, EF error_cb) {
    initialize();

    constexpr bool has_return_type = std::negation<std::is_same<void, std::invoke_result_t<F>>>::value;

    try {
        try {
            if constexpr(has_return_type) {
                write_value(make_call());
            } else {
                make_call();
            }
        } catch (E &e) {
            status->code = 1;
            status->error_buf = error_cb(e);
        }
    } catch (std::exception &e) {
        status->code = 2;
        status->error_buf = {{ Type::String.borrow()|lower_fn }}(e.what());
    }
}


{% include "rust_buf_tmpl.cpp" %}

{{ internal_type_helper_code }}
} // namespace uniffi

{{ type_helper_code }}

{%- for func in ci.function_definitions() %}
{% include "fn_def.cpp" %}
{% endfor -%}
} // namespace {{ namespace }}
